<html>
	<head>
		<meta charset = "utf-8"/>
	</head>
		<body>
			<?php
				/*
					函数
						预定义函数：php已经定义好的函数
							is_numeric() is_int() var_dump()
						自定义函数:
							语法
								function 函数名(参数)
								{
									函数体
									return; 中断函数的执行
								}
						1.定义时使用的参数，其实就是一个变量--只能在该函数内部使用的变量
						2.形参作为变量，其名字是"自己定义"--自然应该遵循命名规范
						3.实参应该和要调用的函数的形参--对应
						4.实参就是数据值
					函数调用的详细过程
						1.首先，将函数调用时的实参数据，传递给函数的形参
						2.程序的执行流程，进入到函数的内部，此时可以认为是一个跟外界'隔离'的独立空间
						3.在函数内部，按正常的流程顺序，执行其中的代码
						4.直到函数结束，则退出，而返回到原来调用该函数的位置，继续执行后面的代码
						5.如果在函数内部执行的过程中，有return语句，则也会立即终止函数，并回到函数调用的位置
					函数的参数问题
						函数形参的默认值问题
						我们可以给一个函数定义时的形参，赋值一个“默认值”，则这个函数调用的时候，该形参对应的实参可以不给值
					形参的传值问题
						其实就是变量之间的传值问题
						值传递：
							这是默认值，如果没有特别设定，参数传递都是值传递
						引用传递：
							需要在形参的前面加&符号 
					参数的数量问题
						1.通常，函数的实参数量，应该跟函数定义时的形参数量保持一致
						2.如果函数定义时，形参有默认值，则对应的实参就可以进行一定程度的省略
							注意：省略只能从右往左
						3.有一种定义和使用函数的特别形式（不常见）：不定义形参，实参任意给出
							其实，系统中也有类似的函数，比如
								var_dump($v1);
								var_dump($v1,$v2,$v3)
							可见该函数可以接受任意个数的实参
							我们自己也可以定义这种函数，其实，这种函数，以来的是以下三个系统函数来获取
							相应的信息，以得到实参数据的处理
							如下
								func_get_args() //获取实参数据列表，成为一个数组
								func_get_arg($i) //获取第$i个实参数据，$i从0开始算起
								func_num_args() //获取实参的个数;
							function cai()
							{
								//系统函数func_get_args()可以获取函数调用时传递过来的
								//所有实参数据，并且都放入一个数组中
								$arr = func_get_args();
								foreach($arr as $value)
								{
									echo $value;
								}
							}
							cai(1,2,3)
					函数返回值问题
						观念问题
							函数的返回值不是语法规定，而是应用所需，需要就返回，不需要就无须返回
							返回值，一定是通过return语句
						注意：
							return语句的作用，不管后面跟不跟数据值，都会立即终止函数的执行，返回得到函数调用的位置并继续执行后续的工作
					可变函数
						一个函数的名字还是一个变量
					匿名函数
						没有名字的函数
						有2中形式的匿名函数
						形式1：将一个匿名函数赋值给一个变量--此时该变量就代表一个匿名甘薯了
						形式2：是直接将一个匿名函数当做‘实参’来使用，--即调用“别的函数a”
								的时候，使用一个匿名函数，来当做实参，自然，在该函数a中，
								也就应该对该匿名函数当做一个函数来用
					变量的作用域
						变量的作用域就是指，一个变量在什么范围中可以使用的情况
						php中，有三种作用域
							局部作用域
								就是指一个函数的内部范围
									对应这样的变量就是局部变量
							超全局作用域
								就是指所有代码范围
									对应这样的变量就是超全局变量
										其实系统预定义的几个:$_GET,$_POST,$_SERVER,$_REQUEST,$GLOBALS,$_SESSION,$_COOKIE,$_FILES
							全局作用域
								就是不在函数内部的范围--函数外部
									对应这样的变量就是全局变量	
						通常：
							1.全局范围不能访问局部变量
							2.局部范围不能访问全局变量
							3.函数内部的变量(局部变量)，在函数调用执行结束后，就被“销毁”了。
							4.但有一种局部变量， 在函数调用结束后不被销毁，叫做静态变量；
							使用形式
								function 函数名()
								{
									static $变量名 = 初始值; 	//这就是静态变量!
								}
						如何在局部作用域使用(访问)全局变量？
							有2种做法
								1.使用global关键字来实现
								2.使用$GLOBALS超全局变量来实现
									如果我们对$GLOBALS变量的某个下标进行unset，则其就回完全销毁该变量
									这是因为.$GLOBALS对全局变量的使用可以看做是全局变量的另一种语法形式而已，
									而不是引用关系
						有关函数的系统函数
							function_exists:判断一个函数是否被定义
							func_get_args() //获取实参数据列表，成为一个数组
							func_get_arg($i) //获取第$i个实参数据，$i从0开始算起
							func_num_args() //获取实参的个数;
						其他系统函数
							自己会查
								时间函数
								字符串函数
								数学函数
						有关函数的编程思想
							递归思想--递归函数
								递归函数就是在一个函数内部调用它本身的函数
								下面函数例子的基本模式是
									function digui()
									{
										if(是最小一级)
										{
											return 已知的答案
										}
										$jieguo = 对 digui($n-1)进行简单运算;
										return $jieguo;
									}
									digui();
							递推(迭代)思想
								演示求5的阶乘，最初级的做法
									$a1 = 1;
									$a2 = $a1 * 2;
									$a3 = $a2 * 3;
									$a4 = $a3 * 4;
									$a5 = $a4 * 5;
								改进后有			
									$a = 1;
									$a = $a * 2;
									$a = $a * 3;
									$a = $a * 4;
									$a = $a * 5;	
								再次改进后有
								$jieguo = 1; 前一个已知的答案，：这就是第一个，就是1的阶乘
								for($i = 2;$i <= 5;++$i)
								{
									此循环会从2的阶乘开始，一次次求得
									更大的一个数的阶乘，直到5的阶乘
									$jieguo = $jieguo * $i; //i的阶乘
								}
								递推总结
									如果要求一个大问题，且该问题有如下2个特点
										1.已知该问题的同类问题的最小问题的答案。
										2.如果直到这种问题的小一级问题的答案，就可以轻松求得其大一级问题的答案 
										并且此问题的级是有一定的规律
									则此时就可以使用递推思想来解决该问题，代码模式为
										$qian = 已知最小一级的问题的答案；
										for($i = 最小一级的下一级;$i <= 最大一级的级次;++$i)
										{
											$jieguo = 对$qian进行一定的运算，通常需要使用到$i;
											$qian = $jieguo;
										}
										echo $jieguo;	
								通常：如果一个问题既能使用递归解决，又能使用递推，则使用递推
					*/
				function getmax($a,$b) //形参
				{
					if($a > $b)
					{
						$max = $a;
					}else
					{
						$max = $b;
					}
					return $max;	//返回给函数调用的地方
				}
				echo getmax(20,30) + 10;  //实参
				echo '<br>';
				$num1 = 10;
				function cal()
				{
					$num2 = 20;
					echo $GLOBALS['num1']+$num2."<br>";  //php中的全局变量和js中的全局变量不一样，要想函数外部的变量在函数内部访问，需要加GLOBALS,js中全局变量可以在函数内部访问.
				}
				cal();
				function cai()
				{
					//系统函数func_get_args()可以获取函数调用时传递过来的
					//所有实参数据，并且都放入一个数组中
					$arr = func_get_args();
					echo count($arr)."<br>";
					foreach($arr as $value)
					{
						echo $value." ";
					}
				}
				cai(1,2,3);
				function f1()
				{
					echo "<br>这是一个可变函数";
				}
				$v1 = "f1";
				$v1();	//这就是可变函数
				//可变函数其实就是在调用函数的时候，使用一个变量名而已
				//该变量的内部就是该函数名
				function jpg(){echo "<br>处理jpg图片";}
				function png(){echo "<br>处理png图片";}
				function gif(){echo "<br>处理gif图片";}
				$file = "abc.png";//代表用户上传的图片
								  //其后缀可能是png.gif.jpg
				$houzhui = strrchr($file,'.');
				//strrchr($s1,$s2)函数用于获取字符串$s1中最后一次出现的字符$s2之后的所有字符串内容(包含$s2本身)
				echo $houzhui;
				$houzhui = substr($houzhui,1);
				$houzhui();
				//将一个匿名函数，赋值给一个变量f1
				//匿名函数形式1
				$f1 = function ($a,$b)
				{
					$sum = $a + $b;
					return $sum;
					//echo "<br>这是一个匿名函数";
				};
				echo "<br>".$f1(1,2);	//调用该匿名函数其形式和可变函数一样
				//匿名函数形式2
				function func1($a,$b,$c)
				{
					$sum = $a + $b;
					$cha = $a - $b;
					$c($sum,$cha);
				}
				func1(4,3,
						  function ($a1,$a2)
						  {
							 echo "<br>a1 = $a1, a2 = $a2"; 
						  });
				//全局变量和局部变量的访问
				//错误访问例子
				/*
				$a = 1;
				function nima()
				{
					$b = 10;
					echo "a = $a";
				}
				nima();
				echo "b = $b";
				*/
				echo "<br>//静态变量";
				function f3()
				{
					static $c = 0;	//静态局部变量，它的值会保留，
					$c++;
					$a = 0;			//函数内部变量，除了静态局部变量，函数执行完之后，数据会被销毁
					$a++;
					echo "<br>a = $a,c = $c";
				}
				f3();
				f3();
				f3();
				//局部变量访问全局变量实例
				//*
				$a = 4;
				function f4()
				{
					echo "<br>a = ". $GLOBALS['a'];
					$GLOBALS['a'] = 55;//修改其值
					//unset($GLOBALS['a']);
				}
				f4();
				echo "<br>在全局再次访问a =".$a;
				$a = 4;
				function f5()
				{
					global $a; //在函数中，使用global来声明一个要使用的全局变量的同名局部变量
								//这里，$a是局部变量，只是跟全局的$a同名
								//实际情况是：此时外部$a变量跟内部的$a变量共同指向一个数据区--引用关系
					//unset($a);
					echo "<br>在局部访问全局变量a = $a";
					$a = 44;
					unset($a); //此时不影响
				}
				f5();
				echo "<br>在全局访问a = $a";
				//*/
				//递归函数
				function yoyo($n)
				{
					echo "<br>".$n;
					$n++;
					if($n == 10)
					{
						exit;
					}
					else
					{
						yoyo($n);
					}
				}
				yoyo(1);
				/*递归函数调用是永无止境的，最终会将内存消耗完毕
				显然这不是一个正常的做法！
				实用的递归函数是能够控制调用的过程中，会在某个时刻(条件)停下来
				*/
				//实例：5的阶乘
				echo "5的阶乘<br />";
				function fuck($a)
				{
					if($a == 1)
					{
						return 1;
					}
					$jieguo = $a * fuck($a-1);
					return $jieguo;
				}
				$p = fuck;
				echo $p(5);
				//思想总结：将面对一个大问题，该大问题可以经由该问题的同类问题的'小一级'问题而经过简单计算获得
				//而且可以获知这类问题的‘最小一级’问题的答案,则此时可以使用递归方法来解决该问题
				//演示调用过程
				//	5 * fuck(4)
				//	5 * (4 * fuck(3))
				//	5 * (4 * (3 * fuck(2)))
				//	5 * (4 * (3 * 2 * fuck(1)))
			?>
		</body>
</html>