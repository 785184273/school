<html>
	<head>
		<meta charset = "utf-8"/>
	</head>
		<body>
			<?php
				/*
				数组基础
					数组的含义
						数组就是一系列数据的集合体，他们按设定的顺序，排列为一个"链的形状"
						注意：php中的数组单元的顺序，跟下标无关
					数组的定义(赋值)
						$arr1 = array(3,11,5);最常见的数组，下标为默认下标，就是从0开始的整数
						$arr2 = array("a" => 3, "bb" => 11)关联数组，下标为字符串，常见
						$arr3 = array(1 => 3,0 => 2,2 => 4);下标可以人为的设定
						$arr4 = array(1 => 3,"a1" => 11);下标可以数字和字符串混合使用
						$arr5 = array(5 => 3,11,3 => 5,'mn' => 14); 有指定下标，也有自动下标
																	此时下标是5，6，3，mn
																	可见自动下标为前面最大数字下标+1
						$arr6 = array(5 => 3,7.7 => 11);此时下标为5，7,下标自动转换为整数
						$arr7 = array(5 => 3,true => 11,false => 5);此时下标是5，1，0
						$arr8 = array(1 => 3,3 =>33,true => 11);此时的下标为1，3对应的值我11，33
																//下标如果有重复，后面的值覆盖前面的值
						$arr9 = array(1 => 3,-3 =>33,11,) //此时的下标为1，-3，2,注意：最后一个逗号可以有
						其他的一些形式
							$arr10[] = 3;
							$arr10[] = 11;
							$arr10[] = 5; //该数组下标为0，1，2，常规情况下
							$arr11[1] = 1;
							$arr11[] = 2; //此时的下标为2
						特别注意：在php中，数组单元的顺序是其"放入"顺序决定，而不是其下标
					数组的取值
						$v1 = $arr[0];	//取得数组下标为0的单元的值
						总体上，可以将去的一个数组的单元的值，看做取得一个变量的值完全一样	
					数组的分类
						按照键分：索引数组
									通常认为，如果一个数组的下标是严格按照从0开始的连续的
									整数作为下标，和js数组类似的下标
								  关联数组
									通常认为，如果一个数组的下标都是一个字符串，并在一定程度上
									表明了该单元的含义
								  混合数组
									既有数字下标，也有字符串下标的情况
						按数组的维数分：一维数组
											$a = array(1,11,111);
										二位数组
											$a = array(
														array(1,11,111),
														array(2,22,222,2222),
														array(3,33,333,3333,33333)
														
											);
										多维数组
				数组的基本使用
					求一个一维数组的平均值：
					求一个二维数组的平均值；
					求一个一维数组的最大值；
					求交换一个一维数组的最大值和最小值的位置
				关于数组的元素的交换
					例如：
						需求1：交换数组的第0项和第3项；
						$a = array(1,2,3,4,5)
						$v1 = $a[0];
						$v2 = $a[3];
						$t = $v1;
						$v1 = $v2;
						$v2 = $t;		//这种做法根本不可行，因为v1,v2只是2个变量，跟数组没关系！
						正确的做法
						$t = $a[0];
						$a[0] = $a[3];
						$a[3] = $t;
						需求2：交换数组的第0项和最后一项
						$t = $a[0];
						$a[0] = $a[count($a)-1];
						$a[count($a)-1] = $t;
						需求3：交换数组的最大项和最小项
							1.求出数组的最大项下标
							2.求出数组的最小项下标
							3.交换方法同上
				数组的基本遍历
					foreach基本语法
						foreach($数组变量名 as 【$key =>】 $value)
						{
							//循环体;这里可以使用$key和$value;
							$key和$value就是该遍历语句一次次取得的数组的每一个单元项的下标和对应值
							而且总是从数组的开头往后按顺序取得数据
						}
				数组的指针操作和遍历原理
					$a = array(1 => 3,2 => 2,3 => 6,4 => 8)
					可以将其视觉化的理解为
								|
					数组下标	1	2	3	4
					对应数据 	3	2	6	8
					其中，该箭头，就是数组内部的所谓"指针"，注意：不可见，不可输出，只是一种辅助理解的图形
				说明:
					1.该箭头，就是数组内部的所谓"指针"
					2.默认情况下，该指针指向数组的第一个单元
					3.数组的有关单元的操作，如果没有指定下标，则就是针对该指针指向的单元的操作
					4.所谓遍历其实就是一次次取得当前单元的键($key)和值($value)，并放入对应的变量，然后移动指针到下一个单元
				则，数组，作为一个"总体数据单位"，有如下指针操作函数可以使用
					1.$a = current($数组);	获得数组的当前指针所在的单元的值
					2.$a = key($数组);	获得数组的当前指针所在单元的键(下标)
					3.$a = next($数组);	先将数组的指针移向下一个单元，然后取得该新单元的值
					4.$a = prev($数组);	先将数组的指针移向上一个单元，然后取得该新单元的值
					5.$a = end($数组);	先将数组的指针移向最后一个单元，然后取得该新单元的值
					6.$a = reset($数组); 先将数组的指针直接移向第一个单元，然后取得该新单元的值
				使用for和next遍历数组
					注意：对php数组，不能单纯使用for循环进行遍历
						或者说，php中，使用for循环只能循环"下标为连续的纯整数数组"
				list()函数的应用
					list()函数用于一次性取得一个数组中从0开始的数字下标的多个单元的值
						形式
							list($变量1,$变量2,$变量3,....) = $数组
						作用
							上述一行代码相当于如下代码
								$变量1 = $数组[0];
								$变量2 = $数组[1];
								......
						注意：这里变量的个数，要跟该数组的数字下标的单元对位，如果某个变量的对应的该数字下标不存在就会报错
				数组遍历的一些细节
					foreach也是正常的循环语法结构，可以有break和continue等操作
					遍历过程中，值变量默认的传值方式是值传递
					遍历过程中，值变量可以人为设定为引用传递:foreach($arr as $key => &$value){......}
					foreach默认是原数组上进行的遍历，但如果在遍历过程中对数组进行了某种
						修改或某种的指针性操作，则会复制数组后在复制的数组上继续循环遍历(原数组保持不变)
					foreach中如果值变量是引用传递，则无论如何都在原数组上进行
				常用的数组函数
					排序函数简单的演示
					sort():对数组进行升序排序，同时删除了原来的键名
					asort():对数组进行升序排序，排序后的数组还保持和键名之间的关系
					ksort()；对数组键名进行升序排序，
					rsort(): 同sort();降序排列
					arsort()：同asort():降序排列
					krsort():同ksort():降序排列
					natsort():该函数实现了一个和人们通常对字母，数字，字符串进行排序的方法一样的排序算法
							  ，并保持原有的键/值的关系，natsort()函数对大小写敏感,natcasesort()函数不区分大小写
					shuffle():将数组用随机的顺序排序，并删除原来的键名，建立自动索引
					array_reverse($变量名，[true|false])；该函数是将数组单元按相反的顺序排序
														可选项为true则保留原来的键名，为false则为数组重新建立索引
					array_multisort():可以一次对多个数组进行排序，
									可选项：1排序顺序标志：SORT_ASC:为默认值，按照上升顺序排序
															SORT_DESC:为按照下降顺序排序
									可选项：2排序类型标志: SORT_REGULAR:为默认值，按照通常方法比较
															SORT_NUMERIC:为按照数值比较
															SORT_STRING:为按照字符串比较
				冒泡排序算法
					演示数组为
						$a = array(9,3,2,5,8,7) //下标为：0,1,2,3,4,5
					演算过程描述
						从数组的左边开始，依次两两比较相邻的两个数据的大小，如果发现左边比右边大，则进行交换
						这样进行一趟后，必然可以确定最大的一个数据放在最右边,按此方式，继续进行下一趟，
						则又会确定这些剩余数据最大值放在剩余位置的最右边	
					演示
					原始数组：	9	3	5	8	2	7
					第一趟		3	5	8	2	7	9
					第二趟		3	5	2	7	8	
					第三趟		3	2	5	7
					第四趟		2	3	5
					第五趟		2	3
					规律描述
						1.假设数组的数据有n个
						2.要进行比较的趟数为n-1
						3.每一趟要比较的数据个数都比前一趟少一个，第一趟要比n个(n - 1次)
						4.每一次比较如果发现左边数据大于右边数据，就对两者进行交换位置
				选择排序
					演示数组为
						$a = array(9,3,2,5,8,7) //下标为：0,1,2,3,4,5
					演算过程描述
						求得一个数组的最大值的下标，并将最大值下标单元跟最后一个单元进行交换
						然后，继续从剩余数据中取得最大值的下标，并将这个最大值下标的单元跟剩余的最后一个单元交换
						依此类推，直到只剩下最后一个数据
					演示
					原始数组：	9	3	5	8	2	7
					第一趟		7	3	5	8	2	9
					第二趟		7	3	5	2	8
					第三趟		2	3	5	7
					第四趟		2	3	5
					第五趟		2	3
					规律描述
						1.假设数组的数据有n个
						2.要进行查找最大值单元并进行交换的"趟数"为n-1
						3.每一趟都要求出"剩余数据中的最大值单元"，并且，剩余数据的数量每一趟都少1个，第一趟有n个
						4.每一趟找出最大值单元后，都要进行交换：最大值单元跟剩余数据中的最后一个单元进行交换
				数组的查找算法
					所谓查找算法，大体是主要解决这样的一个问题：找出某个数组中，是否存在某个值
					1.顺序查找
						就是遍历该数组，一个一个的判断，如果相等，就表示有，然后退出就ok
						$a = array(11,13,1,8,2,3,1,123)
					2.二分查找
						二分查找算法的前提，
							1.针对的是索引数组
							2.针对的是已经排好序的数组
						有关二分查找算法的效率(性能)问题的一点说明
							1000个数据约10次找出
							100W个数据，约20次找出
							10Y个数据，约30次找出
							40Y个数据，约32次找出
				*/
			$stu = array(
						array('tom','nimei','timi'),
						array('李白','白居易','杜甫')
						);
			echo "<br/>".$stu[0][0];
			//求一个一维数组的平均值：
			echo "<br/>//求一个一维数组的平均值：";
			$arr = array(1,2,3,4,5,6,7);
			$sum = 0;
			$len = count($arr);
			for($i = 0;$i < $len;++$i)
			{
				$sum = $sum + $arr[$i];
			}
			$av = $sum/$len;
			echo "<br/>".$av;
			//求一个一维数组的最大值；
			echo "<br/>//求一个一维数组的最大值；";
			$arr1 = array(1,8,4,19,3,50,7);
			$max = $arr1[0];
			$len = count($arr1);
			$c = 0;
			for($i = 1;$i < $len;$i++)
			{
				if($arr1[$i] > $max)
				{
					$max = $arr1[$i];
					$c = $i;
				}
			}
			echo "<br/>".$max;
			echo "<br/>".$c;
			//求一个二维数组的平均值；
			echo "<br/>//求一个二维数组的平均值；";
			$a = array(
						array(1,11,111),
						array(2,22,222,2222),
						array(3,33,333,3333,33333)
			);
			$len = count($a);
			$sum = 0;
			$c = 0;
			for($i = 0;$i < $len;++$i)
			{
				$temp = $a[$i];
				$len2 = count($temp);
				for($j = 0;$j < $len2;++$j)
				{
					$sum = $sum + $temp[$j];
					$c++;
				}
			}
			echo "<br>".($sum/$c);
			//求交换一个一维数组的最大值和最小值的位置
			echo "<br/>//求交换一个一维数组的最大值和最小值的位置:";
			$arr1 = array(1,8,4,19,3,50,7);
			echo "<br/>交换之前的位置是:";print_r($arr1);
			$max = $arr1[0];
			$min = $arr1[0];
			$len = count($arr1);
			$c = 0;
			$c1 = 0;
			for($i = 1;$i < $len;$i++)
			{
				if($arr1[$i] > $max)
				{
					$max = $arr1[$i];
					$c = $i;
				}
				if($arr1[$i] < $min)
				{
					$min = $arr[$i];
					$c1 = $i;
				}
			}
			$t = $arr1[$c];
			$arr1[$c] = $arr1[$c1];
			$arr1[$c1] = $t;
			echo "<br/>最大值为：".$max." 下标为：".$c;
			echo "<br/>最小值为：".$min." 下标为：".$c1;
			echo "<br/>交换之后的位置是:";print_r($arr1);
			//指针
			echo "<br/>//指针实例；";
			$a = array(3,2,3,8);
			$v1 = current($a);
			$v2 = key($a);	//获得当前单元的键
			echo "<br/>初始单元的下标和值为：".$v2.",".$v1;
			$v3 = next($a);	//移动到下一个然后获得其值
			$v4 = key($a);
			echo "<br/>当前单元的值和下标为：".$v3.",".$v4;
			$arr4 = array(3,2,3,8);
			foreach($arr4 as $key => $value)
			{
				echo "<br/>".$key." =>". $value;
			}
			$k = key($arr4);
			$v = current($arr4);
			echo "<br/>此时(遍历之后)的位置为:";var_dump($k);
			echo "<br/>此时(遍历之后)对应值为:";var_dump($v);
			//使用for循环和next()函数，遍历以下数组(输出其下标及对应的值)；
			echo "<br/>//使用for循环和next()函数，遍历以下数组(输出其下标及对应的值)；";
			$arr5 = array(1 => 3,'a1' => 11,3 => 5,'mn' => 18,88 => 2);
			$len = count($arr5);
			for($i = 0;$i < $len;++$i)	//$i控制循环的次数
			{
				$key = key($arr5);		//获得当前项的键
				$value = current($arr5);		//获得当前项的值
				echo "<br/>$key => $value";
				next($arr5);		//对当前项数据处理完毕，就将指针后移一位
			}
			//list
			echo "<br/>//list()的应用：";
			$c = array(0 => 0,1 => 11,2 => 222,3 => 333);
			list($v1) = $c;
			list($v2,$v3) = $c;
			echo "<br/>v1 = $v1";  //将数组c的下标为0 的项赋值给v1
			echo "<br/>v2 = $v2,v3 = $v3";	//将数组c的下标为0和1的项对应赋值给v2,v3
			//使用while和each和list配合来遍历该数组
			echo "<br/>//使用while和each和list配合来遍历该数组:";
			$arr6 = array(1 => 3,'a1' => 11,3 => 5,'mn' => 18,88 => 2);
			while(list($key,$value) = each($arr6))
			{
				echo "<br/>$key = $value";
			}
			//each()
			echo "<br/>//each():";
			$a = array(1,2,3,4,5);
			$c = each($a);
			print_r($c);
			//foreach演示值传递
			echo "<br/>//foreach演示值传递:";
			$arr7 = array(1 => 3,'a1' => 11,3 => 5,'mn' => 18,88 => 2);
			foreach($arr7 as $key => $value)
			{
				//var_dump($value);	//foreach循环后$value不是数组 
				$value = $value * 2;
				echo "<br/>$key > $value";	//遍历过程中，值变量默认的传值方式是值传递
			}
			var_dump($arr7);
			//foreach值变量的引用传递方式
			echo "<br/>//foreach演示引用传递:";
			$arr8 = array(1 => 3,'a1' => 11,3 => 5,'mn' => 18,88 => 2);
			foreach($arr8 as $key => & $value)
			{
				//var_dump($value);	//foreach循环后$value不是数组 
				$value = $value * 2;
				echo "<br/>$key > $value";	//遍历过程中，值变量默认的传值方式是应用传递
			}
			var_dump($arr8);
			//foreach默认是在原数组上进行遍历的
			echo "<br/>//foreach默认是在原数组上进行遍历的";
			$arr9 = array(1 => 3,'a1' => 11,3 => 5,'mn' => 18,88 => 2);
			foreach($arr9 as $k1 => $v1)
			{
				echo "<br/>$k1 ； $v1";
				if($k1 == 3)
				{
					break;
				}
			}
			$r1 = current($arr9);
			$r2 = key($arr9);
			echo "<br/>此时数组指针指向的单元为：$r2 => $r1";
			//foreach在某些情况下不是在原数组身上进行遍历
			echo "<br/>//foreach在某些情况下不是在原数组身上进行遍历:";
			$arr10 = array(1 => 3,'a1' => 11,3 => 5,'mn' => 18,88 => 2);
			foreach($arr10 as $k1 => $v1)
			{
				echo "<br/>$k1 ； $v1";
				if($k1 == 3)
				{
					$arr10[11] = "新的数据项";
					//当我们循环到中途，对该数组添加了一项，而且是添加到数组的末尾
				}
			}
			echo "<br/>此时该项已经添加进去了：";print_r($arr10);
			//在foreach循环过程中，值变量使用"引用传递"则无论如何都是在原数组上进行的
			$arr11 = array(1 => 3,'a1' => 11,3 => 5,'mn' => 18,88 => 2);
			foreach($arr11 as $k1 => & $v1)
			{
				echo "<br/>$k1 ； $v1";
				if($k1 == 3)
				{
					$arr11[11] = "新的数据项";
					//即当我们循环到中途，对该数组添加了一项
					//而且是添加到数组的末尾，这里因为是引用传递，新项到最后也会取得
				}
			}
			//echo "<br/>此时该项已经添加进去了：";print_r($arr11);
			//数组sort()函数排序
			echo "<br/>数组sort()函数排序：";
			$arr12 = array(1 => 3,'a1' => 11,3 => 5,'mn' => 18,88 => 2);
			echo "<br/>排序前：";print_r($arr12);
			sort($arr12);
			echo "<br/>排序后：";print_r($arr12);
			//数组asort()函数排序
			echo "<br/>数组asort()函数排序：";
			$arr12 = array(1 => 3,'a1' => 11,3 => 5,'mn' => 18,88 => 2);
			echo "<br/>排序前：";print_r($arr12);
			asort($arr12);
			echo "<br/>排序后：";print_r($arr12);
			//数组ksort()函数排序
			echo "<br/>数组ksort()函数排序：";
			$arr12 = array(1 => 3,'a1' => 11,3 => 5,'mn' => 18,88 => 2);
			echo "<br/>排序前：";print_r($arr12);
			ksort($arr12);
			echo "<br/>排序后：";print_r($arr12);
			//数组rsort()函数排序
			echo "<br/>数组rsort()函数排序：";
			$arr12 = array(1 => 3,'a1' => 11,3 => 5,'mn' => 18,88 => 2);
			echo "<br/>排序前：";print_r($arr12);
			rsort($arr12);
			echo "<br/>排序后：";print_r($arr12);
			//数组arsort()函数排序
			echo "<br/>数组arsort()函数排序：";
			$arr12 = array(1 => 3,'a1' => 11,3 => 5,'mn' => 18,88 => 2);
			echo "<br/>排序前：";print_r($arr12);
			arsort($arr12);
			echo "<br/>排序后：";print_r($arr12);
			//数组krsort()函数排序
			echo "<br/>数组krsort()函数排序：";
			$arr12 = array(1 => 3,'a1' => 11,3 => 5,'mn' => 18,88 => 2);
			echo "<br/>排序前：";print_r($arr12);
			krsort($arr12);
			echo "<br/>排序后：";print_r($arr12);
			//数组natsort()函数升序排序
			echo "<br/>数组natsort()函数排序：";
			$arr12 = array(1 => "image10",'a1' => "image0",3 => "image3",'mn' => "image4",88 => "image5");
			echo "<br/>排序前：";print_r($arr12);
			natsort($arr12);
			echo "<br/>排序后：";print_r($arr12);
			//数组shuffle()函数排序
			echo "<br/>数组shuffle()函数排序：";
			$arr12 = array(1 => 3,'a1' => 11,3 => 5,'mn' => 18,88 => 2);
			echo "<br/>排序前：";print_r($arr12);
			shuffle($arr12);
			echo "<br/>排序后：";print_r($arr12);
			//数组array_reverse()函数排序
			echo "<br/>数组array_reverse()函数排序：";
			$arr12 = array(1 => 3,'a1' => 11,3 => 5,'mn' => 18,88 => 2);
			echo "<br/>排序前：";print_r($arr12);
			$a1 = array_reverse($arr12); //默认情况下可选项为true;
			echo "<br/>排序后：";print_r($a1);
			//冒泡排序实例
			echo "<br/>冒泡排序：";
			$a = array(9,3,5,8,2,7);
			echo "<br/>排序之前:";print_r($a);
			$n = count($a);
			for($i = 0;$i < $n - 1;++$i)
			{
				for($k = 0;$k < $n - $i - 1;++$k)
				{
					if($a[$k] > $a[$k + 1])
					{
						$str = $a[$k];
						$a[$k] = $a[$k + 1];
						$a[$k + 1] = $str;
					}
				}
			}
			echo "<br/>排序之后:";print_r($a);
			//选择排序
			echo "<br/>//选择排序:";
			$b = array(9,3,5,8,2,7);
			echo "<br/>排序之前:";print_r($b);
			$n = count($b);
			for($i = 0;$i < $n - 1;++$i)
			{
				$max = $b[0];
				$c = 0;
				for($k = 0;$k < $n - $i;++$k)
				{
					if($b[$k] > $max)
					{
						$max = $b[$k];
						$c = $k;
					}
				}
				$str = $b[$c];
				$b[$c] = $b[$n - $i - 1];
				$b[$n - $i - 1] = $str;
			}
			echo "<br/>排序之后:";print_r($b);
			//二分查找
			echo "<br/>二分查找：";
			$a = array(1,3,11,18,19,22,25,33,34,38,44,55,56,58,60,61,66,70,77,88,90,91,93,95,98);
			$search = 4;
			$len = count($a);
			function binary_search($a,$search,$start,$end)
			{
				if($start > $end)
				{
					return false;
				}else
				{
					$middle = ceil(($start + $end)/2);
					if($a[$middle] == $search)
					{
						return true;
					}else if($a[$middle] > $search)
					{
						$re = binary_search($a,$search,$start,($middle - 1));
					}else
					{
						$re = binary_search($a,$search,($middle + 1),$end);
					}
				}
				return $re;
			}
			$v = binary_search($a,$search,0,($len - 1));
			echo "结果为：";var_dump($v);
			//数组长度不同使用的区别
			$a = microtime(true);
			$arr = array(1,2,3,4,5,6,7,8,9,10,11,12,14,14,15,12,123,123,1233,123,1223,123,123,123,12,323);
			$sum = 0;
			for($i = 0;$i < count($arr);++$i){
				$sum = $sum + $arr[$i];
			}
			echo $sum;
			$b = microtime(true);
			echo $b-$a . "<br />";
			$c = microtime(true);
			$arr1 = array(1,2,3,4,5,6,7,8,9,10,11,12,14,14,15,12,123,123,1233,123,1223,123,123,123,12,323);
			$sum = 0;
			$len = count($arr1);
			for($i = 0;$i < $len;++$i){
				$sum = $sum + $arr[$i];
			}
			echo $sum;
			$d = microtime(true);
			echo $d-$c . "<br />";
			//注意；js中数组长度的获取是数组最大下标加1
			//php中则不是
			$arr = array(1,2,3,4,5);
			$arr[21] = 10;
			echo count($arr);
			?>
		</body>
</html>