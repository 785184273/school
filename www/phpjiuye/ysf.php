<meta charset = "utf-8"/>
<?php
	/*echo 11.3%3;
	echo "<hr>";
	$a = 'a';
	$b = 'A';
	$c = "C";
	$d = "傻逼";
	$a++;$b++;$c++;$d++;
	echo $a,$b,$c,$d."<hr>";
	$v1 = 1;
	$v2 = 1;
	echo $v1++;
	echo ++$v2;
	echo "<hr>";
	echo (10 & 20)."<br>";
	echo (10 | 20)."<br>";
	echo (~20)."<br>";
	echo (10 << 1)."<br>";
	echo (10 >> 2)."<br>";*/
	//假设有5个灯泡需要管理，需要实现以下功能目标
	//1.可以指定任意一个灯泡的'当前状态'
	//2.可以打开指定的任意一个灯泡
	//3.可以关闭指定的任意一个灯泡
	
	//首先，需要设定对应的5个常量，代表对应的5个灯泡
	
	/*$a = microtime(true);//获得当前时间离9170,1,1当前的秒数
	for($i = 1;$i < 100000000;++$i)
	{
		
	}
	$a1 = microtime(true);
	for($i = 1;$i < 100000000;$i++)
	{
		
	}
	$a2 = microtime(true);
	echo $a1 - $a."<br>";
	echo $a2 - $a1;*/
	$arr1 = array(5 => 10,8 => 20,10 => 30);
	$arr2 = array(5 => 33,2 => 22);
	$a = $arr1 + $arr2;
	var_dump($a);
?>
<!--
算数运算符
	基础
	符号有：+  - * / %
	说明：
		1.他们都是针对数字进行的运算
		2.如果他们的两边有不是数字的数据，就会(自动)转换为数字
		3.其中取余运算(取模运算)%,它只针对整数进行运算，如果不是，会自动截取整数
			11.3 % 3 = 2
自增自减运算符
	常规：对数字进行自加1或自减1
	字符串：只能自增，且自增的效果就是“下一个字符,只能针对字母或数字”;
	布尔值递增递减无效
	null递减无效，递增结果为1
前自增和后自增的区别
	前加加是先对自加变量加1，然后做其他运算
	后加加是先做其他运算，然后对自加变量加1
	通常，我们在循环中，推荐使用前加加，比如
	for($i = 1;$i < 10000;++$i)
	{
		.......
	}
	演示前加加后加加进行1千万次的“效率比较”;
	/*$a = microtime(true);
	for($i = 1;$i < 100000000;++$i)
	{
		
	}
	$a1 = microtime(true);
	for($i = 1;$i < 100000000;$i++)
	{
		
	}
	$a2 = microtime(true);
	echo $a1 - $a."<br>";
	echo $a2 - $a1;*/
比较运算符
	符号：>	 >=  <  <=  ==  !=  ===  !==
	一般比较：是针对数字进行的大小比较
	==和===比较：前者通常叫做模糊相等的比较，后者叫做精确相等的比较
	（只有数据的类型和数据的值/内容，都相等才是全等的）附录：php类型比较表
	不要对浮点数直接进行大小比较
常见不同类型(标量类型)数据之间的比较规律
	如果比较的数据中，有布尔值，则转为布尔值比较，布尔值比较只有一个规则：true>false
	有数字转为数字比较
	两边都是纯数字字符串，转为数字比较
	否则就按字符串比较，字符串比较的规则是：
		对两边的字符串，一个一个从前往后取出字符并进行比较，谁“先大”,结果是它大
		"abc" > "c" false 后者大
		"abc" > "abc123def" true c大于1
		"3abc" > "12abc" true 这是字符串，3大于1
	附录：php类型比较表
逻辑运算符
	逻辑运算符都是针对"布尔值"进行的运算
	如果不是布尔值，就会转换为布尔值
	布尔值只有两个：true false
	基本运算规则(真值表)
	 逻辑与规则： &&	只有两个都是true结果才是true	只要有一个是false结果就是false
	 	如果一个语句中，通过与运算需要进行多项判断，而且不同的判断具有明显不同的"复杂程度"
		则我们应该将简单的判断放在前面，这时候我们可以利用短路现象来达到提高效率的目的
	 逻辑或规则： ||	只有2个都是false结果才是false，只要有一个是true结果就是true
		如果一个语句中，通过或运算需要进行多项判断，而且不同的判断具有明显不同的"复杂程度"
		则我们应该将简单的判断放在前面，这时候我们可以利用短路现象来达到提高效率的目的
	 逻辑非规则：!true = false		!false = true;
字符串运算符
	1.符号只有一个： 也衍生出另一个： .=   和js中的+=是类似的
	2.含义：就是将这个符号两边的字符串连接起来
	3.如果两边不是字符串，就会自动转换成字符串，然后连接起来
赋值运算符
	一个基本赋值运算符： =
		形式：$变量名 = 值；
		理解：将右边的值(不管做了多少运算)，赋值给左边的变量
	若干个衍生的赋值运算符
		+=   形式 $变量名 += 值
			理解：相当于：$变量名= $变量名 + 值;
		.= 	 形式 $变量名 .= 值
			理解：相当于：$变量名= $变量名 . 值;
	*=  /=  %= .= 其都可以认为是上述形式的一种简化
条件运算符(三目，三元)运算符
	只有一个，形式如下
		数据值1？ 数据值2：数据值3
	含义：对数据值1进行判断，如果为“真”，则运算符的运算结果就是数据值2，否则就是数据值3
	它就是一个了流程控制（逻辑判断）语句的简写形式
		if（数据值1）
		{
			数据值2
		}else
		{
			数据值3
		}
	注意：如果数据值1不是布尔值，也会转换为布尔值
位运算符
	基础规定
	1.位就是2进制数字的每一个“位”，一个整数数字有（由）32个位构成！
	2.位运算符是仅仅针对整数进行的运算
	3.位运算符有如下几个
		&：按位与
		|:按位或
		~：按位非
		^:按位异或
	4.位运算符的基本语法规则
		按位与基本规则
			1 & 1 = 1
			1 & 0 = 0
			0 & 1 = 0
			0 & 0 = 0
		按位或基本规则
			1 | 1 = 1
			1 | 0 = 1
			0 | 1 = 1
			0 | 0 = 0
		按位非基本规则
			~1 = 0
			~0 = 1
		按位异或基本规则：可见相同为0，不同为1
			1 ^ 1 = 0
			1 ^ 0 = 1
			0 ^ 1 = 1
			0 ^ 0 = 0
整数的按位与运算(&)
	形式
		$a & $b   //a ，b是两个任意整数
	含义：将2个整数的2进制数字形式（注意：都是32位）的每一个对应位上的数字进行基本按位与运算之后的结果
		图示(只用8个位来演示)
		10的2进制	0	0	0	0	1	0	1	0
		20的2进制	0	0	0	1	0	1	0	0
			&		0	0	0	0	0	0	0	0
			代码验证：$a = 10 & 20;
整数的按位或运算
	形式
		$a | $b   //a ，b是两个任意整数
	含义：将2个整数的2进制数字形式（注意：都是32位）的每一个对应位上的数字进行基本按位或运算之后的结果
		图示(只用8个位来演示)
		10的2进制	0	0	0	0	1	0	1	0
		20的2进制	0	0	0	1	0	1	0	0
			|		0	0	0	1	1	1	1	0
			数据值大小为：1*2^4 + 1*2^3 + 1*2^2 + 1*2 + 0  = 30
			代码验证：$a = 10 | 20;	
整数的按位左移运算
	形式
		$n1 << $m
	含义：将10进制数字n1的2进制数字形式(也是32位的)的每一个位上的数字都一次性往左边移动
	m位，并将右边空出来的位置补0，左边冒出来的不管，
		10 << 2
		10的2进制	0	0	0	0	1	0	1	0
		左移2位后	0	0	1	0	1	0	0	0
		   结果				2^5		2^3
		   2^5 + 2^3 = 40
位运算符的应用：管理一组事物的开关状态
	什么是开关状态
		现实中，有很多数据都只有2种结果(值)的,对应的其实就是我们的布尔类型的值
		所谓管理一组事物的开关状态，应该理解为其实就是管理若干个只有2个状态的“数据符号”
			比如：有5个灯泡，对应5个状态数据
				这5个灯泡就有2^5种状态.
		这里的管理目标是：使用一个变量，就可以表达若干个数据的"当前状态"
			1.通过该变量，可以获知任何一个数据(灯泡)的当前状态
			2.通过该变量，可以将一个一个数据的状态"关闭"
			3.通过该变量，可以将一个一个数据的状态"开启"
数组运算符
	+	
		数组联合(数组串联)：将右边的数组项合并到左边数组的后面，得到一个新数组，如有重复键，则结果以左边的为准
		$arr1 = array(5 => 10,8 => 20,10 => 30);
		$arr2 = array(3 => 33,2 => 22);
		$a = $arr1 + $arr2;
		$a = (5 => 10,8 => 20,10 => 30,3 => 33,2 => 22);
		重复键的例子
		$arr1 = array(5 => 10,8 => 20,10 => 30);
		$arr2 = array(5 => 33,2 => 22);
		$a = $arr1 + $arr2;
		$a = (5 => 10,8 => 20,10 => 30,2 => 22)
	==
		如果两个数组具有相同的键名和键值（可以顺序不同， 类型不同），则返回true；
		$arr1 = array(3 => 33,2 => 22);
		$arr2 = array(2 => "22",3 => 33);
		此时，$arr1 == $arr2;
	===
		如果两个数组具有相同的键名和键值且顺序合理类型一样，则返回true
		$arr2 = array(3 => 33,2 => 22);
		$arr1 = array(3 => 33,2 => 22);
		此时 $arr1 === $arr2;
	!==
	!=
错误控制运算符
	通常用在一个地方
	$link = @mysql_connect("localhost","root","123456");
	作用是：
		如果连接数据库的语句失败（比如连接不上）,则屏蔽失败的错误提示
运算符的优先级
	运算符都有优先级问题
		括号最优先，赋值最落后(通常)
		先乘除再加减
		
		
-->